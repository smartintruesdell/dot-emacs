#+title:GNU EMACS CONFIGURATION
#+author:Shawn Martin-Truesdell
#+email:shawn@martin-truesdell.com

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]] using [[https://orgmode.org/][org-mode]].

See =./config.el= for the generated file.

* Emacs Initialization

** Preamble

#+begin_src emacs-lisp :tangle yes
  ;;; mt-config --- Shawn Martin-Truesdell's Emacs Configuration
  ;;; License:
  ;; ---------------------------------------------------------------------
  ;; Copyright (C) 2022 - Shawn Martin-Truesdell
  ;;
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  ;; ---------------------------------------------------------------------
  ;;; Commentary:
  ;; DO NOT EDIT THIS FILE DIRECTLY
  ;; This is a file generated from a literate programing source file.
  ;; You should make any changes there and regenerate it from Emacs org-mode
  ;; using C-c C-v t
  ;; ---------------------------------------------------------------------
  ;;; Code:
#+end_src

** Straight.el

=straight.el= is a replacement for =package.el=, which is the default package manager for EMACs. It's pretty fancy, and instead of pulling compiled blobs it synchronizes local repositories for each package and allows for easy local editing of those repositories.

#+begin_src emacs-lisp :tangle yes
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Utilities

#+begin_src emacs-lisp :tangle yes
  (defun my-adjoin-to-list-or-symbol (element list-or-symbol)
    (let ((list (if (not (listp list-or-symbol))
                    (list list-or-symbol)
                  list-or-symbol)))
      (require 'cl-lib)
      (cl-adjoin element list)))
#+end_src

** use-package

To be able to manage its configuration with =use-package= it is necessary to
first install it

#+BEGIN_SRC emacs-lisp :tangle yes
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
  (setq use-package-always-demand t)

  (use-package dash)
#+END_SRC

* Start Up
** exec-path-from-shell

We don't want Emacs to use a different PATH setting from the rest of our
OS, so we'll take advantage of the =exec-path-from-shell= package.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :config
    (setq exec-path-from-shell-variables '("PATH"))
    (exec-path-from-shell-initialize))
#+END_SRC

** Better Defaults

For a better user experience of GNU Emacs, here are the default values I use.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default
   ad-redefinition-action 'accept                   ; Silence warnings for redefinition
   cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
   display-time-default-load-average nil            ; Don't display load average
   fill-column 80                                   ; Set width for automatic line breaks
   help-window-select t                             ; Focus new help windows when opened
   indent-tabs-mode nil                             ; Use spaces instead of tabs
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   kill-ring-max 128                                ; Maximum length of kill ring
   load-prefer-newer t                              ; Prefers the newest version of a file
   mark-ring-max 128                                ; Maximum length of mark ring
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   tab-width 2                                      ; Set width for tabs
   user-full-name "Shawn Martin-Truesdell"          ; Set the full name of the current user
   user-mail-address "shawntruesdell@gmail.com"     ; Set the email address of the current user
   vc-follow-symlinks t                             ; Always follow the symlinks
   view-read-only t)                                ; Always open read-only buffers in view-mode
  (cd "~/")                                         ; Move to the user directory
  (column-number-mode 1)                            ; Show the column number
  (display-time-mode 1)                             ; Enable time in the mode-line
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  (global-hl-line-mode)                             ; Hightlight current line
  (set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
  (show-paren-mode 1)                               ; Show the parent
  (setq backup-directory-alist '(("." . "~/.emacs-saves")))
  (setq ring-bell-function 'ignore)                 ; No more dings
  (global-unset-key (kbd "C-z"))                    ; No more minimizing on accident
  (pixel-scroll-precision-mode)
#+END_SRC

** Unicode Fonts support

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package unicode-fonts
  :init (unicode-fonts-setup))
#+END_SRC

** Better file management with XDG

To keep the user's home and the =~/.emacs.d= folder as clean as possible, I
follow the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][XDG base directory specification]].

Be careful that GNU Emacs will not create the appropriate folders if they do not
exist. Therefore, it is necessary to create them yourself:

#+BEGIN_SRC bash
  mkdir ~/.cache/emacs ~/AppData/Roaming/emacs/
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun default-to (fb val)
    (if (eq nil val)
        fb
      val))
  (defvar xdg-bin (default-to "~/.local/bin" (getenv "XDG_BIN_HOME"))
    "The XDG bin base directory.")

  (defvar xdg-cache (default-to "~/.cache" (getenv "XDG_CACHE_HOME"))
    "The XDG cache base directory.")

  (defvar xdg-config (default-to "~/.config" (getenv "XDG_CONFIG_HOME"))
    "The XDG config base directory.")

  (defvar xdg-data (default-to "~/.local/share" (getenv "XDG_DATA_HOME"))
    "The XDG data base directory.")

  (defvar xdg-lib (default-to "~/.local/lib" (getenv "XDG_LIB_HOME"))
    "The XDG lib base directory.")
#+END_SRC

** Customization

To avoid overloading the GNU Emacs custormization =init.el= file made by the
user with the UI, I add the generated code in a separate file.

I also made sure to follow the XDG base directory specification for the
=auto-save-file= folder, in order to keep my =~/.emacs.d= folder clean.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default
   ;; Autosave Directory
   auto-save-list-file-name (expand-file-name (format "%s/emacs/auto-save-list" xdg-data))
   ;; Session customizations
   custom-file (expand-file-name (format "%s/emacs/custom.el" xdg-data)))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+END_SRC

** Keep Autosave/Temp files corraled

Emacs fills your directories with =#filename= temporary files and =filename~= backups, and I hate it.
Instead, I want those to be kept together in a separate folder so that my source directories remain uncluttered.

#+begin_src emacs-lisp :tangle yes
  ;;; my/set-autosave-file-directory --- Sets the autosave/temp file directory
  ;;; Commentary:
  ;;; Code:
  (defun my/set-autosave-file-directory ()
    "Set the autosave/temp file directory."
    (let ((user-temporary-file-directory (concat temporary-file-directory user-login-name "/")))
      (make-directory user-temporary-file-directory t)
      (setq create-lockfiles nil)
      ;; Lockfiles are creating the '.#______' files that are messing up dev servers
      (setq backup-by-copying t)
      (setq backup-directory-alist
            `(("." . ,user-temporary-file-directory)
              (,tramp-file-name-regexp nil)))
      (setq auto-save-list-file-prefix
            (concat user-temporary-file-directory ".auto-saves-"))
      (setq auto-save-file-name-transforms
            `((".*" ,(expand-file-name "\\2" user-temporary-file-directory) t)))))

  (my/set-autosave-file-directory)
#+end_src


** No-Alt Extended Commands

=M-x= is a chord we use ALL THE TIME, and having it right under the center of our left palm is super bad for our ergonomics. Instead, we're going to bind a new chord to make it more convenient.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
#+END_SRC

** Prefer backward-kill-word

#+begin_quote
Emacs Wizards try to avoid hitting the backspace key, because it's just remote enough from home-row to be annoying. We make typing mistakes all the time, but if you type faster than about 50 wpm, it's more economical to kill the entire word and re-type it than to painstakingly backspace to your error.
#+end_quote

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
#+END_SRC

** Fix the Frame Title

Such a silly little thing, but I can't get rid of the frame title bar so I'm going to at least make it a little nicer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default frame-title-format '("Shawn's Emacs :: %b"))
#+END_SRC

** Prefer pixel-scroll-mode
#+BEGIN_SRC emacs-lisp :tangle no
  ;; DISABLED by :tangle no
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
#+END_SRC

** (removed) Diminish allows us to simplify the modeline
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package diminish)
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nano-theme
    :straight (nano-theme :type git :host github :repo "rougier/nano-theme")
    :custom
    (nano-fonts-use t)
    (nano-light-salient "SteelBlue3")
    :init (load-theme 'nano-light t))
  (use-package nano-modeline
    :straight (nano-modeline :type git :host github :repo "rougier/nano-modeline")
    :init (nano-modeline-mode))
#+end_src

*** Old Theme
#+BEGIN_SRC emacs-lisp :tangle no
      ;; (use-package flucui-themes)
      ;; (use-package doom-themes
      ;;   <<theme-faces>>
      ;;   :config
      ;;   (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
      ;;   ;(load-theme 'flucui-light t))
      ;;   (load-theme 'github-modern t))

      (use-package doom-modeline
        :straight (doom-modeline :type git :host github :repo "seagle0128/doom-modeline")
        :hook
        (after-init . doom-modeline-mode)
        :custom
        (doom-modeline-height 30)
        :custom-face
        (mode-line ((t (:height 80))))
        (mode-line-inactive ((t (:height 80)))))
  ;      (doom-modeline-bar ((t (:background "#5EC4FF")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  ;; :custom-face TODO
  :custom-face
  (org-table ((t (:background "#ECECEC"))))
#+END_SRC


** Turn off mouse interface

Since I never use the mouse with GNU Emacs, I prefer not to use certain
graphical elements as seen as the menu bar, toolbar, scrollbar and tooltip that
I find invasive.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode -1)              ; Disable the menu bar
    (scroll-bar-mode -1)            ; Disable the scroll bar
    (tool-bar-mode -1)              ; Disable the tool bar
    (tooltip-mode -1))              ; Disable the tooltips
#+END_SRC


* Org Mode

Org-Mode is the killer feature, and after basic text editing ergonomics it is THE main reason to use Emacs. We love it for its organizational tools, it's presentational tools, and for the awesome power of literate programming.

#+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export
  (use-package org-contrib)
  (use-package org
      :after org-contrib
      :init
      <<org-mode-fn-definitions>>
      :bind
      (:map org-mode-map
            <<org-mode-keybindings>>)
      :custom-face
      <<org-mode-faces>>
      :hook
      <<org-mode-hooks>>
      :custom
      <<org-mode-custom-variables>>
      :config
      <<org-mode-config>>)

    ;; Maintains a clean TOC in the first section with the :TOC: tag.
    (use-package toc-org
      :after org
      :hook (org-mode . toc-org-enable))
    ;; Cleans up "online mode" when connecting using TRAMP
    (use-package org-indent :straight nil :after org)
#+END_SRC

** Utility Function Definitions

*** Compare Logged and Estimated times

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-fn-definitions
  (defun my/org-compare-times (clocked estimated)
    "Gets the ratio between the timed time and the estimated time."
    (if (and (> (length clocked) 0) estimated)
        (format "%.2f"
                (/ (* 1.0 (org-hh:mm-string-to-minutes clocked))
                   (org-hh:mm-string-to-minutes estimated)))
      ""))
#+END_SRC

*** Automagically archive finished tasks

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-fn-definitions
  (defun my/org-archive-done-tasks ()
    "Archives finished or cancelled tasks."
    (interactive)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "TODO=\"DONE\"|TODO=\"CANCELLED\"" (if (org-before-first-heading-p) 'file 'tree)))
#+END_SRC

** Hooks

*** Auto-Tangle when saving the config file
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (after-save . my/config-tangle)
#+END_SRC

*** Auto-Indent when loading an Org file

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-mode . org-indent-mode)
#+END_SRC

** Boilerplate Customizations

*** Set file paths

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-archive-location "~/.personal/archives/%s::")
  (org-ditaa-jar-path "~/.local/lib/ditaa0_9.jar")
#+END_SRC

*** Setup Org-Crypt for encrypted org entries

#+begin_src emacs-lisp :tangle yes
  ;(require 'epa-file)
  (custom-set-variables '(epg-gpg-program  "/usr/bin/gpg2"))
  (epa-file-enable)

  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance '("crypt"))
  ;;  set to nil to use symmetric encryption.
  (setq org-crypt-key nil)
#+end_src

*** Load Org modules to add new features

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-modules '(org-crypt
                 org-habit
                 org-info
                 org-mouse
                 org-protocol))
#+END_SRC

*** Tags and Todo Settings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-tag-alist '(("@work" . ?w)
                   ("@errands" . ?e)
                   ("@home" . ?h)
                   ("@kiddo" . ?k)
                   ("@phone" . ?p)
                   ("@reading" . ?r)
                   ("@admin" . ?a)
                   ("fuzzy" . ?0)))
  (org-tags-exclude-from-inheritance '("crypt" "project"))
  (org-todo-keywords '((sequence "TODO(t)"
                                 "STARTED(s)"
                                 "WAITING(w@/!)"
                                 "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")))
#+END_SRC

*** Set up Org Refile to make it a little more robust

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-refile-allow-creating-parent-nodes 'confirm)
  (org-refile-use-cache nil)
  (org-refile-use-outline-path t)
  (org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
#+END_SRC

*** Automatically log done times

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-log-done 'time)
  (org-log-into-drawer "LOGBOOK")
#+END_SRC

*** Open src blocks in the same window

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-src-window-setup 'current-window)
#+END_SRC

*** Hide Emphasis (bold, fixed-width, etc) Markers

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-hide-emphasis-markers t)
#+END_SRC

*** Other settings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-blank-before-new-entry '((heading . t)))
  (org-cycle-include-plain-lists 'integrate)
  (org-expiry-inactive-timestamps t)
  ;;Removed |beamer icalendar man org texinfo| as unused
  (org-export-backends '(ascii html latex md))
  (org-startup-folded nil)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  (org-use-effective-time t)
  (org-yank-adjusted-subtrees t)
#+END_SRC

** Beautification
*** Enable mixed pitch to allow src blocks in fixed-pitch

This elisp function lets us set the face without clearing out other customizations (colors, underscores, etc).

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (defun my-adjoin-to-list-or-symbol (element list-or-symbol)
    (let ((list (if (not (listp list-or-symbol))
                    (list list-or-symbol)
                  list-or-symbol)))
      (require 'cl-lib)
      (cl-adjoin element list)))
  (defun fix-org-block-faces ()
    (mapc
     (lambda (face)
       (set-face-attribute
        face nil
        :inherit
        (my-adjoin-to-list-or-symbol
         'fixed-pitch
         (face-attribute face :inherit))))
     (list
      'org-block-begin-line
      'org-block
      'org-block-end-line
      'org-verbatim
      'org-drawer
      'org-special-keyword
      'org-table
      'org-date
      'org-meta-line
      'org-link)))
  (add-hook 'org-mode-hook #'fix-org-block-faces)
#+END_SRC

*** Hide keywords

I'm not super attached to seeing =#+TITLE:= in the page header, so I take'em out.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-hidden-keywords '(author email subtitle title))
#+end_src

*** Emphasis, lists and bullets

These settings make org-mode much more readable by using different fonts for headings, hiding some of the markup, etc. This was taken originally from Howard Abrams' [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]], and subsequently tweaked and broken up in the different parts of the =use-package= declaration by me.

First, we set =org-hid-emphasis-markers= so that the markup indicators are not shown.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (org-hide-emphasis-markers t)
#+end_src

We add an entry to the org-mode font-lock table so that list markers are shown with a middle dot instead of the original character.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

We use the =org-bullets= package to display the titles with nice unicode bullets instead of the text ones.

#+begin_src emacs-lisp :tangle yes
  (use-package org-superstar
    :after org
    :hook
    (org-mode . org-superstar-mode)
    :custom
    (org-superstar-headline-bullets-list '("▪"
                                           "▫"
                                           "•"
                                           "◦"
                                           )))
#+end_src

Prettify checkbox lists and other symbols - courtesy of https://blog.jft.rocks/emacs/unicode-for-orgmode-checkboxes.html. First, we add special characters for checkboxes:

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
  (org-mode . (lambda ()
                "Beautify Org Checkbox Symbol"
                (push '("[ ]" . "☐" ) prettify-symbols-alist)
                (push '("[X]" . "☑" ) prettify-symbols-alist)
                (push '("[-]" . "⊡" ) prettify-symbols-alist)
                (prettify-symbols-mode)))
#+end_src

Show symbols when the cursor is over of right after them.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
  (prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

Second, we define a special face for checked items.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (defface org-checkbox-done-text
    '((t (:foreground "#71696A" :strike-through t)))
    "Face for the text part of a checked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
      1 'org-checkbox-done-text prepend))
   'append)
#+end_src

*** Headings

We choose a nice font for the document title and the section headings. The first one found in the system from the list below is used, and the same font is used for the different levels, in varying sizes.

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-config
  (let* ((variable-tuple
          (cond ((x-list-fonts   "Futura Round")    '(:font   "Futura Round"))
                ((x-list-fonts   "ETBembo")         '(:font   "ETBembo"))
                ((x-list-fonts   "Source Sans Pro") '(:font   "Source Sans Pro"))
                ((x-list-fonts   "Lucida Grande")   '(:font   "Lucida Grande"))
                ((x-list-fonts   "Verdana")         '(:font   "Verdana"))
                ((x-family-fonts "Sans Serif")      '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font."))))
         (base-font-color (face-foreground 'default nil 'default))
         (headline `(:inherit default :weight bold
                              :foreground "gray25")))

    (custom-theme-set-faces
     'user
     `(org-level-8        ((t (,@headline ,@variable-tuple))))
     `(org-level-7        ((t (,@headline ,@variable-tuple))))
     `(org-level-6        ((t (,@headline ,@variable-tuple))))
     `(org-level-5        ((t (,@headline ,@variable-tuple))))
     `(org-level-4        ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3        ((t (,@headline ,@variable-tuple :height 1.15))))
     `(org-level-2        ((t (,@headline ,@variable-tuple :height 1.2))))
     `(org-level-1        ((t (,@headline ,@variable-tuple :height 1.3))))
     `(org-headline-done  ((t (,@headline ,@variable-tuple :strike-through nil))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

*** Fonts and wrapping

I use proportional fonts in org-mode for the text, while keeping fixed-width fonts for blocks, so that source code, tables, etc. are shown correctly. These settings include:

- Setting up the =fixed-pitch= face to be the same as my usual =default= face. My current one is [[https://github.com/tonsky/FiraCode][Fira Code]]
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (fixed-pitch ((t (:family "Fira Code Retina" :height 120))))
  #+end_src

- Setting code blocks and quotes to have a slightly offset background color.

  #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-faces
    (org-block ((t (:background "gray95"))))
    (org-quote ((t (:background "azure2"))))
  #+END_SRC

- Configure =org-indent= to inherit from =fixed-pitch= to fix the vertical spacing in code blocks. Thanks to Ben for the tip!
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (org-indent ((t (:inherit (org-hide fixed-pitch)))))
  #+end_src

- Configure =org-fontify-done-headline= to apply a special face to DONE items in org-mode, and configure the =org-done= face to be used.  Note that  =org-done= only applies to the "DONE" keyword itself, the face for the rest of a "done" headline is defined above as the =org-headline-done= face.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
    (org-fontify-done-headline t)
  #+end_src

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-faces
    (org-done ((t (:foreground "PaleGreen"
                               :strike-through t))))
    (org-tag  ((t (:height 80 :foreground "snow4"))))
  #+end_src

- Setting up =visual-line-mode= and making all my paragraphs one single line, so that the lines wrap around nicely in the window according to their proportional-font size, instead of at a fixed character count, which does not work so nicely when characters have varying widths. I set up a hook that automatically enables =visual-line-mode= and =variable-pitch-mode= when entering org-mode.
  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-hooks
    (org-mode . visual-line-mode)
    (org-mode . variable-pitch-mode)
  #+end_src

  Turns out =visual-line-mode= also remaps the ~C-a~ and ~C-e~ keybindings (of course, which breaks the behavior enabled by the =org-special-ctrl-a/e/k= variables. To counter this, I also add some bindings that set those keys to their Org functions. These functions know how to deal with visual mode anyway.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-keybindings
    ("C-a" . org-beginning-of-line)
    ("C-e" . org-end-of-line)
    ("C-k" . org-kill-line)
  #+end_src

- In =variable-pitch= mode, the default right-alignment for headline tags doesn't work, and results in the tags being misaligned (as it uses character positions to do the alignment). This setting positions the tags right after the last character of the headline, so at least they are more consistent.

  #+begin_src emacs-lisp :tangle no :noweb-ref org-mode-custom-variables
    (org-tags-column 0)
  #+end_src

  These two modes produce modeline indicators, which I disable using =diminish=.

  #+begin_src emacs-lisp :tangle no :noweb-ref_ org-mode-config
    (eval-after-load 'face-remap '(diminish 'buffer-face-mode))
    (eval-after-load 'simple '(diminish 'visual-line-mode))
  #+end_src

*** Source code blocks
The following code ([[https://pank.eu/blog/pretty-babel-src-blocks.html][by Rasmus]]) prettifies org-mode's source blocks by replacing the =#+begin/end_src= keywords and the header arguments with symbols.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (defvar-local rasmus/org-at-src-begin -1
      "Variable that holds whether last position was a ")

    (defvar rasmus/ob-header-symbol ?☰
      "Symbol used for babel headers")

    (defun rasmus/org-prettify-src--update ()
      (let ((case-fold-search t)
            (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
            found)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (goto-char (match-end 0))
            (let ((args (org-trim
                         (buffer-substring-no-properties (point)
                                                         (line-end-position)))))
              (when (org-string-nw-p args)
                (let ((new-cell (cons args rasmus/ob-header-symbol)))
                  (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                  (cl-pushnew new-cell found :test #'equal)))))
          (setq prettify-symbols-alist
                (cl-set-difference prettify-symbols-alist
                                   (cl-set-difference
                                    (cl-remove-if-not
                                     (lambda (elm)
                                       (eq (cdr elm) rasmus/ob-header-symbol))
                                     prettify-symbols-alist)
                                    found :test #'equal)))
          ;; Clean up old font-lock-keywords.
          (font-lock-remove-keywords nil prettify-symbols--keywords)
          (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
          (font-lock-add-keywords nil prettify-symbols--keywords)
          (while (re-search-forward re nil t)
            (font-lock-flush (line-beginning-position) (line-end-position))))))

    (defun rasmus/org-prettify-src ()
      "Hide src options via `prettify-symbols-mode'.

          `prettify-symbols-mode' is used because it has uncollapasing. It's
          may not be efficient."
      (let* ((case-fold-search t)
             (at-src-block (save-excursion
                             (beginning-of-line)
                             (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
        ;; Test if we moved out of a block.
        (when (or (and rasmus/org-at-src-begin
                       (not at-src-block))
                  ;; File was just opened.
                  (eq rasmus/org-at-src-begin -1))
          (rasmus/org-prettify-src--update))
        ;; Remove composition if at line; doesn't work properly.
        ;; (when at-src-block
        ;;   (with-silent-modifications
        ;;     (remove-text-properties (match-end 0)
        ;;                             (1+ (line-end-position))
        ;;                             '(composition))))
        (setq rasmus/org-at-src-begin at-src-block)))

    ;; This function helps to produce a single glyph out of a
    ;; string. The glyph can then be used in prettify-symbols-alist.
    ;; This function was provided by Ihor in the org-mode mailing list.
    (defun yant/str-to-glyph (str)
      "Transform string into glyph, displayed correctly."
      (let ((composition nil))
        (dolist (char (string-to-list str)
                      (nreverse (cdr composition)))
          (push char composition)
          (push '(Br . Bl) composition))))

    (defun rasmus/org-prettify-symbols ()
      (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
            (cl-reduce 'append
                       (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                               `(("#+begin_src" . ?⎡) ;; ⎡ ➤ 🖝 ➟ ➤ ✎
                                 ;; multi-character strings can be used with something like this:
                                 ;; ("#+begin_src" . ,(yant/str-to-glyph "```"))
                                 ("#+end_src"   . ?⎣) ;; ⎣ ✐
                                 ("#+header:" . ,rasmus/ob-header-symbol)
                                 ("#+begin_quote" . ?«)
                                 ("#+end_quote" . ?»)))))
      (turn-on-prettify-symbols-mode)
      (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
    (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))
#+end_src

** Mode Config

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-mode-config
    ;;(add-to-list 'org-file-apps '(directory . emacs))
    (org-clock-persistence-insinuate)
    (org-load-modules-maybe t)
    (setq org-src-tab-acts-natively t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '(
       (js . t)
       (rust . t)
       (typescript . t)))
    (setq org-babel-js-function-wrapper
          "console.log(require('util').inspect(function(){\n%s\n}(), { depth: 100 }))")
#+END_SRC


** Smart Dashes

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :noweb-ref org-mode-fn-definitions
  (defun help/real-insert (char)
    (cl-flet ((do-insert
               () (if (bound-and-true-p org-mode)
                      (org-self-insert-command 1)
                    (self-insert-command 1))))
      (setq last-command-event char)
      (do-insert)))

  (defun help/insert-em-dash ()
    "Insert a EM-DASH.
  - \"best limited to two appearances per sentence\"
  - \"can be used in place of commas to enhance readability.
     Note, however, that dashes are always more emphatic than
     commas\"
  - \"can replace a pair of parentheses. Dashes are considered
     less formal than parentheses; they are also more intrusive.
     If you want to draw attention to the parenthetical content,
     use dashes. If you want to include the parenthetical content
     more subtly, use parentheses.\"
    - \"Note that when dashes are used in place of parentheses,
       surrounding punctuation should be omitted.\"
  - \"can be used in place of a colon when you want to emphasize
     the conclusion of your sentence. The dash is less formal than
     the colon.\"
  - \"Two em dashes can be used to indicate missing portions of a
     word, whether unknown or intentionally omitted.\"
    - \"When an entire word is missing, either two or three em
       dashes can be used. Whichever length you choose, use it
       consistently throughout your document. Surrounding punctuation
       should be placed as usual.\"
  - \"The em dash is typically used without spaces on either side,
     and that is the style used in this guide. Most newspapers,
     however, set the em dash off with a single space on each side.\"
  Source: URL `https://www.thepunctuationguide.com/em-dash.html'"
    (interactive)
    (help/real-insert ?—))
  (defun help/insert-en-dash ()
    "Insert a EN-DASH.
  - \"is used to represent a span or range of numbers, dates,
     or time. There should be no space between the en dash and
     the adjacent material. Depending on the context, the en
     dash is read as “to” or “through.”\"
    - \"If you introduce a span or range with words such as
       'from' or 'between', do not use the en dash.\"
  - \"is used to report scores or results of contests.\"
  - \"an also be used between words to represent conflict,
     connection, or direction.\"
  - \"When a compound adjective is formed with an element that
     is itself an open compound or hyphenated compound, some
     writers replace the customary hyphen with an en dash. This
     is an aesthetic choice more than anything.
  Source: URL `https://www.thepunctuationguide.com/en-dash.html'"
    (interactive)
    (help/real-insert ?–))
  (defun help/insert-hyphen ()
    "Insert a HYPHEN
  - \"For most writers, the hyphen’s primary function is the
     formation of certain compound terms. The hyphen is also
     used for word division [in typesetting].
  - \"Compound terms are those that consist of more than one
     word but represent a single item or idea.\"
  Source: URL `https://www.thepunctuationguide.com/hyphen.html'"
    (interactive)
    (help/real-insert ?-))
#+END_SRC

#+begin_src emacs-lisp :tangle no :noweb-ref org-mode-keybindings
("-" . help/insert-hyphen)
("s-_" . help/insert-em-dash)
("s--" . help/insert-en-dash)
#+end_src

** Feature Modules
*** Agenda

Nowadays, it is crucial to be organized. Even more than before. That is why it
is important to take the time to make a configuration that is simple to use and
that makes your life easier with an irreproachable organization.

=org-agenda= allows me to be organized with daily tasks. As a result, I can use
my time to the fullest.

I put my =org= files in [[https://github.com/syncthing/syncthing][Syncthing]] in order to be able to check my agenda and
update it from several computers and smartphones.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-agenda
    :straight (:type built-in)
    :after org
    :bind (:map org-agenda-mode-map
                ("X" . my/org-agenda-mark-done-and-add-followup)
                ("x" . my/org-agenda-done))
    :preface
    (defun my/org-agenda-done (&optional arg)
      "Mark current TODO as done.
    This changes the line at point, all other lines in the agenda referring to
    the same tree node, and the headline of the tree node in the Org-mode file."
      (interactive "P")
      (org-agenda-todo "DONE"))

    (defun my/org-agenda-mark-done-and-add-followup ()
      "Mark the current TODO as done and add another task after it.
     Creates it at the same level as the previous task, so it's better to use
     this with to-do items than with projects or headings."
      (interactive)
      (org-agenda-todo "DONE")
      (org-agenda-switch-to)
      (org-capture 0 "t"))
    :custom
    (org-agenda-dim-blocked-tasks t)
    (org-agenda-files '("~/.personal/agenda"))
    (org-agenda-inhibit-startup t)
    (org-agenda-show-log t)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-span 2)
    (org-agenda-start-on-weekday 6)
    (org-agenda-sticky nil)
    (org-agenda-tags-column -100)
    (org-agenda-time-grid '((daily today require-timed)))
    (org-agenda-use-tag-inheritance t)
    (org-columns-default-format "%14SCHEDULED %Effort{:} %1PRIORITY %TODO %50ITEM %TAGS")
    (org-default-notes-file "~/.personal/agenda/organizer.org")
    (org-directory "~/.personal")
    (org-enforce-todo-dependencies t)
    (org-habit-graph-column 80)
    (org-habit-show-habits-only-for-today nil)
    (org-track-ordered-property-with-tag t))
#+END_SRC
*** Capture

=org-capture= templates saves you a lot of time when adding new entries. I use
it to quickly record tasks, ledger entries, notes and other semi-structured
information.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-capture
    :straight (:type built-in)
    :after org
    :preface
    (defvar my/org-basic-task-template "* TODO %^{Task}
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00|8:00|16:00|24:00|32:00|40:00}
  :END:
  %a
  Captured %<%Y-%m-%d %H:%M>" "Template for basic task.")

    (defvar my/org-contacts-template "* %(org-contacts-template-name)
  :PROPERTIES:
  :ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
  :BIRTHDAY: %^{yyyy-mm-dd}
  :EMAIL: %(org-contacts-template-email)
  :NOTE: %^{NOTE}
  :END:" "Template for org-contacts.")
    :custom
    (org-capture-templates
      `(("c" "Contact" entry (file+headline "~/.personal/agenda/contacts.org" "Friends"),
        my/org-contacts-template
        :empty-lines 1)

       ("p" "People" entry (file+headline "~/.personal/agenda/people.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1)

       ("w" "Work" entry (file+headline "~/.personal/agenda/work.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1)

       ("t" "Task" entry (file+headline "~/.personal/agenda/organizer.org" "Tasks"),
        my/org-basic-task-template
        :empty-lines 1))))
#+END_SRC

*** Clock

Being organized is one thing, but being optimal is another. =org-clock= allows
you to estimate your tasks and time them. This is useful, since with experience,
you can have a better estimate of the time that needs to be given to each task.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-clock
    :straight nil
    :after org
    :preface
    (defun my/org-mode-ask-effort ()
      "Ask for an effort estimate when clocking in."
      (unless (org-entry-get (point) "Effort")
        (let ((effort
               (completing-read
                "Effort: "
                (org-entry-get-multivalued-property (point) "Effort"))))
          (unless (equal effort "")
            (org-set-property "Effort" effort)))))
    :hook (org-clock-in-prepare-hook . my/org-mode-ask-effort)
    :custom
    (org-clock-clocktable-default-properties
     '(:block day :maxlevel 3 :scope agenda :link t :compact t :formula %
              :step day :fileskip0 t :stepskip0 t :narrow 80
              :properties ("Effort" "CLOCKSUM" "CLOCKSUM_T" "TODO")))
    (org-clock-continuously nil)
    (org-clock-in-switch-to-state "STARTED")
    (org-clock-out-remove-zero-time-clocks t)
    (org-clock-persist t)
    (org-clock-persist-file (expand-file-name (format "%s/emacs/org-clock-save.el" xdg-cache)))
    (org-clock-persist-query-resume nil)
    (org-clock-report-include-clocking-task t)
    (org-show-notification-handler (lambda (msg) (alert msg))))
#+END_SRC

**** Org-Clock-CSV

My employer uses an ERP driven job cost system for time entry. This is somewhat time consuming to maintain manually, so I trust the =org-clock-csv= package to make exporting my time easier.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Need iso8601 to parse Org-mode date strings YYYY-MM-DD into useful data
  (require 'parse-time)
  (require 'cl)
  (require 'cl-lib)

  ;; Utility for immutable update of a single element in a list
  (defun seq-update-nth (n fn xa)
    "A mechanism for applying `fn` to the `n`th element of `xa` returning a new seq"
    (seq-map-indexed
     (lambda (elt idx)
       (if (eq n idx)
           (funcall fn elt)
         elt))
     xa))

  ;; Utility for picking just values from a plist.
  (defun plist-get-values (plist)
    (if (null plist) nil
      (cons (cadr plist) (plist-get-values (cddr plist)))))

  ;; First some standard customization for org-clock-csv
  (defvar my/custom-org-clock-csv-header "week,employee,date,cost_type,cost_code,explanation,hours,rate,subledger_type,subledger")

  (defun my/org-clock-csv-blocknum-of-timestamp (date-string)
    "Given the start timestamp of a task (2020-01-01 Mon 04:15), determine the 3/4-digit numeric week as a string for the date"
    (let* ((date-elements
            (parse-time-string
             (format-time-string "%Y-%m-%d %a %H:%M" (date-to-time date-string))))
           (day-of-week (nth 6 date-elements))
           (month (nth 4 date-elements))
           (day-of-week-seq
            (seq-map-indexed
             (lambda (date idx) (mod (- day-of-week idx) 7))
             (reverse (number-sequence 1 (- (nth 3 date-elements) 1)))))
           (week
            (seq-reduce
             (lambda (acc day) (if (eq 1 day) (+ acc 1) acc))
             ;; Step over the elapsed days of the month
             day-of-week-seq
             1)))
      (format "%s%s" (org-clock-csv--pad month) (org-clock-csv--pad week))))

  (defun my/org-clock-csv-format-excel-date (date-string)
    "Given the start timestamp of a task (2020-01-01 Mon 04:15), return the US date format of the date portion of that timestamp, ie 01/01/2020"
    (let ((date-elements (parse-time-string date-string)))
      (mapconcat #'identity
                 (list (number-to-string (nth 4 date-elements))
                       (number-to-string (nth 3 date-elements))
                       (number-to-string (nth 5 date-elements)))
                 "/")))

  (defun my/org-clock-duration-to-integer (duration)
    "Given a duration string of shape \"HH:MM\", returns an integer number of minutes elapsed."
    (apply #'+ (seq-map-indexed
                (lambda (val idx)
                  (if (eq idx 0) (* 60 (string-to-number val))
                    (string-to-number val)))
                (split-string duration ":" t))))

  (defun my/get-billable-duration (duration)
    "Given a duration in ##:MM format, returns a number 1.5 in hours, rounded to the nearest appropriate billable multiple of 0.5h."
    (let* ((round-down-to-half-below 40)
           (round-up-to-half-above 10)
           (total-minutes (my/org-clock-duration-to-integer duration))
           (minutes (mod total-minutes 60))
           (hours (+ (/ total-minutes 60)
                     (if (< round-down-to-half-below minutes) 1 0)))
           (minutes (cond ((< round-down-to-half-below minutes) 0)
                          ((> round-up-to-half-above minutes) 0)
                          (t 0.5))))
      (number-to-string (+ hours minutes))))

  (defun my/custom-org-clock-csv-row-fmt (plist)
    "Custom row formatting function."
    (let ((employee-number "81"))
      (mapconcat #'identity
                 (list (my/org-clock-csv-blocknum-of-timestamp
                        (plist-get plist ':start))
                       employee-number
                       (my/org-clock-csv-format-excel-date (plist-get plist ':start))
                       (org-clock-csv--read-property plist "COST_TYPE")
                       (org-clock-csv--read-property plist "COST_CODE")
                       (org-clock-csv--escape (plist-get plist ':task))
                       (my/get-billable-duration (plist-get plist ':duration))
                       (org-clock-csv--read-property plist "BILLABLE_RATE")
                       (org-clock-csv--read-property plist "SUBLEDGER_TYPE")
                       (org-clock-csv--read-property plist "SUBLEDGER"))
                 ",")))

  ;; With the above all set, we want to extend the base org-clock-csv
  ;; to add some advice extending the element aggregation to allow filtering and
  ;; consolidating rows.

  (defun my/integer-to-clock-duration (n)
    "Given a number of elapsed minutes, returns a duration string of shape \"HH:MM\"."
    (format "%s:%s"
            (number-to-string (/ n 60))
            (org-clock-csv--pad (mod n 60))))

  (defun my/combine-durations (&rest durations)
    "Given any number of duration strings of shape \"HH:MM\", combines them together and returns an aggregate duration string in the same shape."
    (my/integer-to-clock-duration
     (seq-reduce
      (lambda (acc duration) (+ acc (my/org-clock-duration-to-integer duration)))
      durations 0)))

  (defun my/sort-datestrings (&rest datestrings)
    "Give any number of Org timestamp date strings of shape \"YYYY-MM-DD ddd HH:MM\", sorts that list in ascending order."
    (sort datestrings
          (lambda (a b) (time-less-p (date-to-time a) (date-to-time b)))))

  (defun my/sort-entries-by-date (entries)
    (sort entries
          (lambda (a b) (time-less-p (date-to-time (plist-get a ':start)) (date-to-time (plist-get b ':start))))))

  (defun my/concat-element-plists (left right)
    "Given two parsed ELEMENT plists, combines them together into a single item"
    (let* ((start (car (my/sort-datestrings (plist-get left ':start) (plist-get right ':start))))
           (end (cadr (my/sort-datestrings (plist-get left ':end) (plist-get right ':end))))
           (combined-duration (my/combine-durations (plist-get left ':duration) (plist-get right ':duration))))
      (list :task (plist-get left ':task)
            :headline (plist-get left ':headline)
            :parents (plist-get left ':parents)
            :title (plist-get left ':title)
            :category (plist-get left ':category)
            :start start
            :end end
            :duration combined-duration
            :properties (plist-get left ':properties)
            :effort (plist-get left ':effort)
            :ishabit (plist-get left ':ishabit)
            :tags (plist-get left ':tags))))

  (defun my/consolidate-entries-get-key (entry)
    "Given a parsed ELEMENT plist, returns a unique path+date key"
    (let* ((split-date (parse-time-string (plist-get entry :start)))
           (year (number-to-string (nth 5 split-date)))
           (month (number-to-string (nth 4 split-date)))
           (day (number-to-string (nth 3 split-date)))
           (fullpath (concat (s-join org-clock-csv-headline-separator (plist-get entry ':parents)) "/" (plist-get entry :task)))
           (keyparts (list fullpath year month day)))
      (mapconcat 'identity keyparts "::")))

  (defun my/consolidate-entries (entries)
    "Given a list of parsed ELEMENT plists, combines tasks with matching paths."
    (plist-get-values
     (seq-reduce
      (lambda (acc entry)
        (let ((key (my/consolidate-entries-get-key entry)))
          (if (lax-plist-get acc key)
              (lax-plist-put acc key (my/concat-element-plists (lax-plist-get acc key) entry))
            (lax-plist-put acc key entry))))
      entries
      nil)))

  (defun my/filter-by-date (entries &optional from-date to-date)
    "Given a date range and a list of entries, filters the entries to only those which fall within the specified dates."
    ;; TODO: There's an issue here where dates that don't have time components
    ;; parse as MUCH earlier time strings. As a result, :start dates are always
    ;; AFTER the from-date, and the whole thing falls over.
    (if (not (or from-date to-date)) entries
      (seq-filter
       (lambda (entry)
         (let ((from-time (if (null from-date) nil (date-to-time from-date)))
               (to-time (if (null to-date) nil (date-to-time to-date)))
               (start (date-to-time (plist-get entry ':start)))
               (end (date-to-time (plist-get entry ':end))))
           (seq-reduce
            (lambda (acc next) (and acc next))
            (list (if (null from-time) t (time-less-p from-time start))
                  (if (null to-time) t (time-less-p end to-time)))
            t)))
       entries)))

  (defun advice-once (symbol where function &optional props)
    (advice-add symbol :after `(lambda (&rest _) (advice-remove ',symbol ',function)))
    (advice-add symbol where function props))

  (defun my/consolidate-and-filter (entries)
    (my/consolidate-entries
     (my/sort-entries-by-date
      (my/filter-by-date
       entries
       (read-string "Start Date:")
       (read-string "End Date:")))))

  (defun my/org-clock-csv (&optional infile no-switch from-date to-date use-current)
    "Custom wrapper around org-clock-csv to add two features I found useful but didn't think merited commiting to the project:

  1. Add entry consolidation
     I want clock entries to be bundled by task/day, so that multiple clocks on the same day are considered part of the same entry.
  2. Add filtering by date range
     I only want to output the last day/week's entries, rather that needing to do post processing to determine which entries are new."
    (interactive)
    (advice-once #'org-clock-csv--get-entries :filter-return #'my/consolidate-and-filter)
    (org-clock-csv infile no-switch use-current))

  (use-package org-clock-csv
    :straight (org-clock-csv :type git :host github :repo "atheriel/org-clock-csv" :fork (:host github :repo "smartintruesdell/org-clock-csv"))
    :after org-clock
    :custom
    (org-clock-csv-header my/custom-org-clock-csv-header)
    (org-clock-csv-row-fmt #'my/custom-org-clock-csv-row-fmt))
#+end_src


*** Languages

With that, I can compile many languages with =org-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ob-emacs-lisp :straight nil :after org)
  (use-package ob-java :straight nil :after org)
  (use-package ob-typescript :straight nil :after org)
  (use-package ob-org :straight nil :after org)
  (use-package ob-python :straight nil :after org)
  (use-package ob-rust :straight nil :after org)
#+END_SRC

*** Typefaces

The Fira Code typeface offers some excellent ligatures, but requires us to make some configuration changes to support those symbols.

I removed the "**" and ="***"= ligatures because they were interfering with Org mode bullets.

#+begin_src emacs-lisp :tangle yes
  (use-package fira-code-mode
    :custom (fira-code-mode-disabled-ligatures '("**" "***"))
    :hook (prog-mode js-mode ts-mode web-mode apex-mode rust-mode)
    :init (add-hook 'after-make-frame-functions #'fira-code-mode--setup))

  (set-frame-font "Fira Code Retina-9") ; Set the default fixed-rhythm font.
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
#+end_src

This was the older, more manual setup that predates =fira-code-mode=
#+BEGIN_SRC emacs-lisp :tangle no

(defun my-correct-symbol-bounds (pretty-alist)
    "Prepend a TAB character to each symbol in this alist,
this way compose-region called by prettify-symbols-mode
will use the correct width of the symbols
instead of the width measured by char-width."
    (mapcar (lambda (el)
              (setcdr el (string ?\t (cdr el)))
              el)
            pretty-alist))

  (defun my-ligature-list (ligatures codepoint-start)
    "Create an alist of strings to replace with
codepoints starting from codepoint-start."
    (let ((codepoints (-iterate '1+ codepoint-start (length ligatures))))
      (-zip-pair ligatures codepoints)))
(setq my-fira-code-ligatures
    (let* ((ligs '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
                  "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
                  "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
                  "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
                  ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
                  "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
                  "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
                  "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
                  ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
                  "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
                  "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
                  "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
                  "x" ":" "+" "+" "*")))
      (my-correct-symbol-bounds (my-ligature-list ligs #Xe100))))

(defun my-set-fira-code-ligatures ()
    "Add Fira Code ligatures for use with prettify-symbols-mode."
    (setq prettify-symbols-alist
          (append my-fira-code-ligatures prettify-symbols-alist))
    (prettify-symbols-mode))

(add-hook 'js-mode-hook 'my-set-fira-code-ligatures)
(add-hook 'java-mode-hook 'my-set-fira-code-ligatures)
(add-hook 'web-mode-hook 'my-set-fira-code-ligatures)
(add-hook 'python-mode-hook 'my-set-fira-code-ligatures)
(add-hook 'apex-mode-hook 'my-set-fira-code-ligatures)

(set-frame-font "Fira Code Retina-9") ; Set the default fixed-rhythm font.
(set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")

#+END_SRC

*** Org-Roam

Roam enables a connected notes network backed by an sqlite database to help
organize your thoughts.

#+BEGIN_SRC emacs-lisp :tangle no
    (add-to-list 'exec-path "C:/Users/Shawn.MASYC/AppData/Roaming/.emacs.d/bin/sqlite3")
    (use-package org-roam
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory (expand-file-name (format "%s/org-roam" xdg-data)))
      (org-roam-index-file (expand-file-name (format "%s/org-roam/index.org")))
      :bind (:map org-roam-mode-map
                  (("C-c n l" . org-roam)
                   ("C-c n f" . org-roam-find-file)
                   ("C-c n g" . org-roam-graph-show))
                  :map org-mode-map
                  (("C-c n i" . org-roam-insert))
                  (("C-c n I" . org-roam-insert-immediate))))

    (use-package graphviz-dot-mode
      :config
      (setq graphviz-dot-indent-width 4))

    (use-package company-org-roam
      :config
      (add-to-list 'company-backends 'company-org-roam))

    (use-package company-graphviz-dot
      )
#+END_SRC


* Software Engineering

I'm a Software Engineer by trade, and Emacs offers me everything I want in an IDE without all of the cruft or mouse based actions.

** LSP

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-mode
    :init
    ;; set prefix for lsp-command-keymap)
    (setq lsp-keymap-prefix "C-c l")
    :hook ((typescript-mode . lsp)
           (rust-mode . lsp)
           (lsp-mode . lsp-enable-which-key-integration))
    :commands lsp)

  (use-package lsp-ivy
    :commands lsp-ivy-workspace-symbol)
#+end_src


** TabNine

Tabnine uses machine learning to do smarter autocomplete.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-tabnine
    :config
    ;; Trigger completion not-quite-immediately.
    (setq company-idle-delay 0.5)

    ;; Number the candidates (use M-1, M-2 etc to select completions).
    (setq company-show-numbers t)

    ;; Use the tab-and-go frontend.
    ;; Allows TAB to select and complete at the same time.
    (company-tng-configure-default)
    (add-to-list 'company-backends 'company-tabnine)
    (setq company-frontends
          '(company-tng-frontend
            company-pseudo-tooltip-frontend
            company-echo-metadata-frontend)))
#+END_SRC
** Common Tools

*** Compiler ANSI colors

I use the compilation-mode a lot to handle things like running tests and builds.

Modern command line tools are using a LOT of ANSI colors and other escape sequences. I don't want to fill my buffer with unreadable noise, so I grabbed this from the stackexchange [[https://emacs.stackexchange.com/questions/24698/ansi-escape-sequences-in-compilation-mode][here]].

#+begin_src emacs-lisp :tangle yes
  ;; Stolen from (http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html)
  (require 'ansi-color)
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
       compilation-filter-start (point))))

  (add-hook 'compilation-filter-hook
            #'endless/colorize-compilation)

  ;; Stolen from (https://oleksandrmanzyuk.wordpress.com/2011/11/05/better-emacs-shell-part-i/)
  (defun regexp-alternatives (regexps)
    "Return the alternation of a list of regexps."
    (mapconcat (lambda (regexp)
                 (concat "\\(?:" regexp "\\)"))
               regexps "\\|"))

  (defvar non-sgr-control-sequence-regexp nil
    "Regexp that matches non-SGR control sequences.")

  (setq non-sgr-control-sequence-regexp
        (regexp-alternatives
         '(;; icon name escape sequences
           "\033\\][0-2];.*?\007"
           ;; non-SGR CSI escape sequences
           "\033\\[\\??[0-9;]*[^0-9;m]"
           ;; noop
           "\012\033\\[2K\033\\[1F"
           )))

  (defun filter-non-sgr-control-sequences-in-region (begin end)
    (save-excursion
      (goto-char begin)
      (while (re-search-forward
              non-sgr-control-sequence-regexp end t)
        (replace-match ""))))

  (defun filter-non-sgr-control-sequences-in-output (ignored)
    (let ((start-marker
           (or comint-last-output-start
               (point-min-marker)))
          (end-marker
           (process-mark
            (get-buffer-process (current-buffer)))))
      (filter-non-sgr-control-sequences-in-region
       start-marker
       end-marker)))

  (add-hook 'comint-output-filter-functions
            'filter-non-sgr-control-sequences-in-output)
#+end_src

*** CSV

In my line of work, I do a surprising amount of CSV data transformation, so the csv-mode gives me a ton of value.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package csv-mode)
#+END_SRC

*** Docker

I like to use Docker when I need to install various databases or other services that only work on a particular operating system while keeping my operating system clean.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package emacs-lisp-mode)
#+END_SRC

**** Eldoc

Provides minibuffer hints when working with Emacs Lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eldoc
    :hook (emacs-lisp-mode . eldoc-mode))
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package json-mode
    :mode ("\\.json\\'" "\\.patch\\'")
    :hook (before-save . my/json-mode-before-save-hook)
    :preface
    (defun my/json-mode-before-save-hook ()
      (when (eq major-mode 'json-mode)
        (json-pretty-print-buffer))))
#+END_SRC

*** Markdown

Before you can use this package, make sure you install =pandoc= on your
operating system.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package markdown-mode
    :mode ("\\.markdown\\'" "\\.md\\'")
    :custom (markdown-command "pandoc"))

  (use-package markdown-preview-mode
    :after markdown-mode
    :custom
    (markdown-preview-javascript
     (list (concat "https://github.com/highlightjs/highlight.js/"
                   "9.15.6/highlight.min.js")
           "<script>
              $(document).on('mdContentChange', function() {
                $('pre code').each(function(i, block)  {
                  hljs.highlightBlock(block);
                });
              });
            </script>"))
    (markdown-preview-stylesheets
     (list (concat "https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/"
                   "3.0.1/github-markdown.min.css")
           (concat "https://github.com/highlightjs/highlight.js/"
                   "9.15.6/styles/github.min.css")

           "<style>
              .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 980px;
                margin: 0 auto;
                padding: 45px;
              }

              @media (max-width: 767px) { .markdown-body { padding: 15px; } }
            </style>")))
#+END_SRC

*** Line Endings

I work a lot on Windows. It's not my favorite OS, but it's what my employer uses and so I'm somewhat locked in.

However, I hate carraige return line feeds. Especially in my source code repositories.

See [[https://www.emacswiki.org/emacs/EndOfLineTips][this EmacsWIKI page]] for details on forcing unix line endings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun no-junk-please-were-unixish ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))

  (add-hook 'find-file-hooks 'no-junk-please-were-unixish)
#+END_SRC

** Web Development
*** CSS – LESS – SCSS

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package css-mode
    :custom (css-indent-offset 2))

  (use-package less-css-mode
    :mode "\\.less\\'")

  (use-package scss-mode
    :mode "\\.scss\\'")
#+END_SRC

*** JavaScript & Typescript (Mostly Typescript)

#+begin_src emacs-lisp :tangle yes
      (use-package js2-mode
        :hook ((js-mode . js2-minor-mode))
        :custom (js-indent-level 2))
      (use-package typescript-mode
        :init
        (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode)))
#+end_src

I like to use [[https://prettier.io/][prettier]] to get my TypeScript code clean. To use it,
don't forget to install it with your package manager.

#+BEGIN_SRC emacs-lisp :tangle yes
      (use-package prettier-js
        :hook ((js-mode . prettier-js-mode)
               (typescript-mode . prettier-js-mode))
        :custom
        (prettier-js-args '("--print-width" "80"
                            "--single-quote" "true"
                            "--trailing-comma" "es5"
                            "--arrow-parens" "always"
                            )))
#+END_SRC

*** Salesforce

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Salesforce Apex bindings
  (use-package apex-mode
    :straight (apex-mode :type git :host github :repo "orangatame/apex-mode")
    :mode ("\\.cls\\'" . apex-mode)
    :mode ("\\.trigger\\'" . apex-mode)
    :mode ("\\.cmp\\'" . web-mode))
#+END_SRC

** Systems Development
*** Rust

Rust is so great. I've been really enjoying the development experience of working on Rust projects, and having Rust support in Emacs has been really helpful.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rust-mode
    :mode ("\\.rs\\'")
    :bind (:map rust-mode-map ("C-c <tab>" . rust-format-buffer)))
  (use-package cargo
    :after rust-mode
    :bind(
          :map rust-mode-map
          ("C-c c" . cargo-process-check)
          ("C-c b" . cargo-process-build)
          ("C-c r" . cargo-process-run)
          ("C-c t" . cargo-process-test)
          ("C-c T" . cargo-process-current-file-tests)
          ("C-c f" . cargo-process-fmt)))
#+END_SRC

*** Flycheck

Flycheck handles linting in *Script and Rust.

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :hook
    (after-init .  global-flycheck-mode))

  (use-package flycheck-rust
    :after rust-mode
    :init
    (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))

#+end_src

*** REST testing

For interacting with REST services, I'm giving restclient.el a try.

#+begin_src emacs-lisp :tangle yes
  (use-package restclient)
#+end_src

* Advanced Configuration
** Alert

Most packages use =alerts= to make notifications with =libnotify=. Don't forget to first install a notification daemon, like =dunst=.

#+BEGIN_QUOTE
Alert is a Growl-workalike for Emacs which uses a common notification interface and multiple, selectable "styles", whose use is fully customizable by the user.

[[https://github.com/jwiegley/alert][John Wiegley]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package alert
    :custom (alert-default-style 'libnotify))
#+END_SRC

** Auto-Completion

=company= provides auto-completion at point and to Displays a small pop-in containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete anything". It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay 0.5)
    (company-minimum-prefix-length 1)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t))
#+END_SRC

** Buffers

Buffers can quickly become a mess. For some people, it's not a problem, but I like being able to find my way easily.

=ibuffer= makes it pretty trivial to kepe my buffer list under control.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))
  (use-package ibuffer-projectile
    :after ibuffer
    :preface
    (defun my/ibuffer-projectile ()
      (ibuffer-projectile-set-filter-groups)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC

** Calculator

In the continuing theme of "I hate having to use another tool (my mouse) for that", =calc= lets me do some pretty sophisticated calculator operations in a buffer window.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package calc
    :custom
    (math-additional-units
     '((GiB "1024 * MiB" "Giga Byte")
       (MiB "1024 * KiB" "Mega Byte")
       (KiB "1024 * B" "Kilo Byte")
       (B nil "Byte")
       (Gib "1024 * Mib" "Giga Bit")
       (Mib "1024 * Kib" "Mega Bit")
       (Kib "1024 * b" "Kilo Bit")
       (b "B / 8" "Bit")))
    (math-units-table nil))
#+END_SRC

** Calendar

Remembering all the dates is not obvious, especially since some varies every year.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package calendar
    :custom (calendar-mark-holidays-flag t))

  (use-package holidays
    :straight nil
    :custom
    (holiday-bahai-holidays nil)
    (holiday-christian-holidays
     '((holiday-easter-etc -47 "Mardi Gras")
       (holiday-easter-etc 0 "Easter")
       (holiday-fixed 11 1 "All Saints' Day")
       (holiday-fixed 12 24 "Christmas Eve")
       (holiday-fixed 12 25 "Christmas Day")))
    (holiday-general-holidays
     '((holiday-fixed 1 1 "New Year's Day")
       (holiday-fixed 2 14 "Valentine's Day")
       (holiday-fixed 3 8 "International Women's Day")
       (holiday-fixed 3 14 "Saint Patrick's Day")
       (holiday-fixed 4 4 "Independence Day")
       (holiday-fixed 10 31 "Halloween")
       (holiday-float 11 4 -1 "Thanksgiving")
       (holiday-fixed 12 31 "New Year's Eve")))
    (holiday-hebrew-holidays nil)
    (holiday-islamic-holidays nil)
    (holiday-local-holidays
     '((holiday-fixed 5 1 "Labor Day")
       (holiday-float 5 0 2 "Mother's Day")
       (holiday-float 6 0 3 "Father's Day")))
    (holiday-other-holidays
     '((holiday-fixed 4 18 "Wedding Anniversary")
       (holiday-fixed 7 9 "Sebastian's Birthday")
       (holiday-fixed 7 16 "Shawn's Birthday")
       (holiday-fixed 8 19 "Alexandra's Birthday")
       (holiday-fixed 10 9 "Susie's Birthday")
       (holiday-fixed 10 22 "Jason's Birthday")))
    (holiday-oriental-holidays nil))
#+END_SRC

** Dashboard

Always good to have a dashboard.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package dashboard
    :init
    (add-hook 'after-init-hook 'dashboard-refresh-buffer)
    (setq dashboard-startup-banner 'logo)
    (setq dashboard-set-heading-icons t)
    (setq dashboard-items '((recents . 5)
                            (bookmarks . 5)
                            (projects . 3)
                            (agenda . 5)
                            ))
    :config
    (dashboard-setup-startup-hook))
#+END_SRC

** Deadgrep

An improved interface for searching in files, ala grep.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package deadgrep
    :bind ("<f5>" . deadgrep))
#+END_SRC

** Dired

For those who didn't know, GNU Emacs is also a file explorer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :straight nil
    :bind (:map dired-mode-map ("M-+" . dired-create-empty-file))
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always)
    :init
    (add-hook 'dired-mode-hook
              (lambda ()
                (dired-hide-details-mode))))
#+END_SRC

** Ending Up

I'm using an =.org= file to maintain my GNU Emacs configuration. However, at his
launch, it will load the =config.el= source file for a faster loading.

The code below, executes =org-babel-tangle= asynchronously when
=config.org= is saved.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package async)

  (defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
    "The configuration file.")

  (defvar *config-last-change* (nth 5 (file-attributes *config-file*))
    "Last modification time of the configuration file.")

  (defvar *show-async-tangle-results* nil
    "Keeps *emacs* async buffers around for later inspection.")

  (defun my/config-updated ()
    "Checks if the configuration file has been updated since the last time."
    (time-less-p *config-last-change*
                 (nth 5 (file-attributes *config-file*))))

  (defun my/config-tangle ()
    "Tangles the org file asynchronously."
    (when (my/config-updated)
      (setq *config-last-change*
            (nth 5 (file-attributes *config-file*)))
      (my/async-babel-tangle *config-file*)))

  (defun my/async-babel-tangle (org-file)
    "Tangles the org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      (async-start
       `(lambda ()
          (require 'org)
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time (time-subtract (current-time)
                                                    ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file)))))))
#+END_SRC

** ERC

ERC is a built-in module for connecting to IRC servers, and I use it with Bitlebee to connect to Discord.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package erc
    :custom
    (erc-fill-function 'erc-fill-static)
    (erc-fill-static-center 22)
    (erc-hide-list '("JOIN" "PART" "QUIT"))
    (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
    (erc-lurker-threshold-time 43200)
    (erc-server-reconnect-attempts 5)
    (erc-server-reconnect-timeout 3)
    (erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                               "324" "329" "332" "333" "353" "477"))
    :config
    (add-to-list 'erc-modules 'notifications)
    (erc-services-mode 1)
    (erc-update-modules))

  (use-package erc-image
    :after erc
    :init
    (add-to-list 'erc-modules 'image)
    (erc-update-modules))
#+END_SRC
** General
*** aggressive-indent

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you do is type. However, once you start shifting blocks around, transposing lines, or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (js-mode . aggressive-indent-mode)
  (use-package aggressive-indent
    :hook ((css-mode . aggressive-indent-mode)
           (emacs-lisp-mode . aggressive-indent-mode)
           (lisp-mode . aggressive-indent-mode))
    :custom (aggressive-indent-comments-too))
#+END_SRC

*** =move-text=

Moves the current line (or if marked, the current region's, whole lines).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down))
    :config (move-text-default-bindings))
#+END_SRC
*** =rainbow-mode=

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :hook (prog-mode))
#+END_SRC

**** Replace the current file with the saved one

Avoids call the function or reload Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package autorevert
    :bind ("C-x R" . revert-buffer)
    :custom (auto-revert-verbose nil)
    :config (global-auto-revert-mode 1))
#+END_SRC
*** =undo-tree=

GNU Emacs's undo system allows you to recover any past state of a buffer. To do
this, Emacs treats "undo itself as another editing that can be undone".

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :bind ("C--" . undo-tree-redo)
    :init (global-undo-tree-mode)
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t))
#+END_SRC

*** =web-mode=

An autonomous emacs major-mode for editing web templates.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package web-mode
    :hook ((css-mode web-mode) . rainbow-mode)
    :mode (("\\.blade\\.php\\'" . web-mode)
           ("\\.html?\\'" . web-mode)
           ("\\.jsx\\'" . web-mode)
           ("\\.php$" . my/php-setup)
           ("\\.tsx\\'" . web-mode))
    :preface
    (defun enable-minor-mode (my-pair)
      "Enable minor mode if filename match the regexp."
      (if (buffer-file-name)
          (if (string-match (car my-pair) buffer-file-name)
              (funcall (cdr my-pair)))))
    :init
    ;; (add-hook 'web-mode-hook
    ;;           (lambda ()
    ;;             (when (string-equal "tsx" (file-name-extension buffer-file-name))
    ;;               (setup-tide-mode))))
    ;; (add-hook 'web-mode-hook
    ;;           (lambda ()
    ;;             (when (string-equal "ts" (file-name-extension buffer-file-name))
    ;;               (setup-tide-mode))))
    :custom
    (web-mode-attr-indent-offset 2)
    (web-mode-block-padding 2)
    (web-mode-css-indent-offset 2)
    (web-mode-code-indent-offset 2)
    (web-mode-comment-style 2)
    (web-mode-enable-current-element-highlight t)
    (web-mode-markup-indent-offset 2))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.js?\\'" . prettier-js-mode))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.jsx?\\'" . prettier-js-mode))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.ts?\\'" . prettier-js-mode))))

  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.tsx?\\'" . prettier-js-mode))))
#+END_SRC

*** =which-key=

It's difficult to remember all the keyboard shortcuts. The =which-key= package helps to solve this.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :config (which-key-mode))
#+END_SRC
** Icons

To integrate icons with =doom-modeline=, =switch-to-buffer=, =counsel-find-file=
and many other functions; [[https://github.com/domtronn/all-the-icons.el/][all-the-icons]] is just the best package that you can
find.

*NOTE:* if it's the first time that you install the package, you must run
=M-x all-the-icons-install-fonts=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package all-the-icons
    :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window)))

  (use-package all-the-icons-dired
;    :diminish all-the-icons-dired-mode
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

** Ivy

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy
    :bind (("C-x C-d" . counsel-dired-jump)
           ("C-x C-h" . counsel-minibuffer-history)
           ("C-x C-l" . counsel-find-library)
           ("C-x C-r" . counsel-recentf)
           ("C-x C-u" . counsel-unicode-char)
           ("C-x C-v" . counsel-set-variable))
    :config (counsel-mode)
    :custom (counsel-rg-base-command "rg -S -M 150 --no-heading --line-number --color never %s"))

  (use-package ivy
    :bind (("C-x b" . ivy-switch-buffer)
           ("C-x B" . ivy-switch-buffer-other-window)
           ("M-H"   . ivy-resume)
           :map ivy-minibuffer-map
                ("<tab>" . ivy-alt-done)
                ("C-i" . ivy-partial-or-done)

           :map ivy-switch-buffer-map
                ("C-k" . ivy-switch-buffer-kill))
    :custom
    (ivy-case-fold-search-default t)
    (ivy-count-format "(%d/%d) ")
    (ivy-re-builders-alist '((t . ivy--regex-plus)))
    (ivy-use-virtual-buffers t)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev)
    :config (ivy-rich-mode 1))

  (use-package all-the-icons-ivy
    :after (all-the-icons ivy)
    :custom (all-the-icons-ivy-buffer-commands '(ivy-switch-buffer-other-window))
    :config
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-dired-jump)
    (add-to-list 'all-the-icons-ivy-file-commands 'counsel-find-library)
    (all-the-icons-ivy-setup))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           :map swiper-map
                ("M-%" . swiper-query-replace)))
#+END_SRC

** Navigation

This function is a mix of =C-a= and =M-m=.

From: http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Moves point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

(global-set-key [remap org-beginning-of-line] #'my/smarter-move-beginning-of-line)
(global-set-key [remap move-beginning-of-line] #'my/smarter-move-beginning-of-line)
#+END_SRC

** Parenthesis

*** =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** =smartparens=

In my opinion, it is the most powerful package to deal with the
parenthesis. Anyway, if you don't like it, you can try taking a look at
=paredit= or =autopair=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :custom (sp-escape-quotes-after-insert nil)
    :config (smartparens-global-mode 1))
#+END_SRC

** Olivetti

This minor mode supports a nicer UX for longform writing. I'm going to give it a shot over perfect-margins-mode because it perports to be more friendly to the kind of work I'm often doing in Org and with Org-roam.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package olivetti
    :custom
    (olivetti-body-width 85)
    :hook
    ((org-mode text-mode prog-mode) . olivetti-mode)
    )
#+END_SRC
** Projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find (but for performance sake an indexing mechanism backed by [[file:../org-roam/20200824145417-external_commands.org][external commands]] exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :custom
    (projectile-cache-file (expand-file-name (format "%s/emacs/projectile.cache" xdg-cache)))
    (projectile-completion-system 'ivy)
    (projectile-enable-caching t)
    (projectile-keymap-prefix (kbd "C-c C-p"))
    (projectile-known-projects-file (expand-file-name (format "%s/emacs/projectile-bookmarks.eld" xdg-cache)))
    (projectile-mode-line '(:eval (projectile-project-name)))
    (projectile-find-dir-include-top-level t)
    :config
    (progn
      (projectile-global-mode)
      (add-to-list 'projectile-globally-ignored-directories "node_modules")
      (add-to-list 'projectile-globally-ignored-directories ".git")))

    (use-package counsel-projectile
    :after (counsel projectile)
    :config (counsel-projectile-mode 1))
#+END_SRC

** Recent Files

Provides fast access to the recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :bind ("C-c r" . recentf-open-files)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "COMMIT_EDITMSG"
                           "~$"
                           "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    (recentf-save-file (expand-file-name (format "%s/emacs/recentf" xdg-cache)))
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+END_SRC
** Version Control

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 80 characters."
      (setq fill-column 80)
      (setq-local comment-auto-fill-only-comments nil)))

  (use-package magit
    :bind (("C-x G" . magit-status)))
#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :init (global-git-gutter-mode +1))
#+END_SRC

Another package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine)
#+END_SRC

** Whitespaces

It is often annoying to see unnecessary blank spaces at the end of a line or file. Let's get ride of them:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :straight nil
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC

*** =hungry-delete=

#+BEGIN_QUOTE
Deleting a whitespace character will delete all whitespace until the next
non-whitespace character.

[[https://github.com/nflath/hungry-delete][Nathaniel Flath]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hungry-delete
:config (global-hungry-delete-mode))
#+END_SRC

** Windows (not the OS)
Most of the time, when I open a new window with =C-x 2= or =C-x 3= it is to
switch directly to it and perform an action. By default, GNU Emacs does not give focus to the new window created. I have no idea why this is not the default behavior. But let's refine these keys:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package window
    :straight nil
    :bind (("C-x 3" . hsplit-last-buffer)
           ("C-x 2" . vsplit-last-buffer))
    :preface
    (defun hsplit-last-buffer ()
      "Gives the focus to the last created horizontal window."
      (interactive)
      (split-window-horizontally)
      (other-window 1))

    (defun vsplit-last-buffer ()
      "Gives the focus to the last created vertical window."
      (interactive)
      (split-window-vertically)
      (other-window 1)))
#+END_SRC

*** =switch-window=

Displays an overlay in each window showing a unique key, then asks the user
where to move in the window.

Most people use =ace-window=, but I prefer =switch-window= because I find this
package more ergonomic by using the fact of displaying the buffer number by
hiding its contents.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package switch-window
    :straight nil
    :bind (("C-x o" . switch-window)
           ("C-x w" . switch-window-then-swap-buffer)))
#+END_SRC

*** =windmove=

Allows you to move from one window to another with something more natural than
cycling through =C-x o= (=other-window=).

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package windmove
    :bind (("C-c h" . windmove-left)
           ("C-c j" . windmove-down)
           ("C-c k" . windmove-up)
           ("C-c l" . windmove-right)))
#+END_SRC

** XML

#+begin_src emacs-lisp :tangle yes
  (use-package hideshow)
  (use-package sgml-mode)
  (add-to-list 'hs-special-modes-alist
               '(nxml-mode
                 "<!--\\|<[^/>]*[^/]>"
                 "-->\\|</[^/>]*[^/]>"

                 "<!--"
                 sgml-skip-tag-forward
                 nil))
#+end_src

* AVY

Avy allows for quickly navigating to an arbitrary point in your buffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package avy
    :bind (("C-:" . avy-goto-char)
           ("C-'" . avy-goto-char-2)
           ("M-g f" . avy-goto-line)
           ("M-g w" . avy-goto-word-1)
           ("M-g e" . avy-goto-word-0)
           ))
#+END_SRC

* YASnippet

Snippets!

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :config (yas-global-mode))

  (use-package yasnippet-snippets
    :after yasnippet
    :config (yasnippet-snippets-initialize))

  (use-package ivy-yasnippet :after yasnippet)

#+END_SRC

* High DPI Displays
In my typical workflow I'm switching between standard and high DPI displays pretty regularly.

To better support this, I've added some libraries to manage frame zooming.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;(load "zoom-frm")
  (defun my-dpi (&optional display)
    "Get the DPI of DISPLAY. DISPLAY is a display name, frame or terminal, as in
     `display-monitor-attributes-list'."
    (cl-flet ((pyth (lambda (w h)
                      (sqrt (+ (* w w)
                               (* h h)))))
              (mm2in (lambda (mm)
                       (/ mm 25.4))))
      (let* ((atts (frame-monitor-attributes))
             (pix-w (cl-fourth (assoc 'geometry atts)))
             (pix-h (cl-fifth (assoc 'geometry atts)))
             (pix-d (pyth pix-w pix-h))
             (mm-w (cl-second (assoc 'mm-size atts)))
             (mm-h (cl-third (assoc 'mm-size atts)))
             (mm-d (pyth mm-w mm-h)))
        (/ pix-d (mm2in mm-d)))))

  (defvar my-zoom-frm-wanted-dpi 70
    "The DPI I want to achieve when using `my-zoom-frm-by-dpi'.")

  (defun my-zoom-frm-by-dpi (&optional frame)
    "Zoom FRAME so the DPI is closer to `my-zoom-frm-wanted-dpi'."
    (interactive)
    (let ((frame (or frame (selected-frame))))
      (when (frame-parameter frame 'zoomed)
        (zoom-frm-unzoom frame))
      (let ((frame-zoom-font-difference (1- (round (/ (my-dpi frame)
                                                      my-zoom-frm-wanted-dpi)))))
        (when (called-interactively-p 'interactive)
          (message "Zooming by %S" frame-zoom-font-difference))
        (zoom-frm-in frame))))

  ;; Apply the scaling I want to each newly created frame:
  (add-hook 'after-make-frame-functions #'my-zoom-frm-by-dpi)
#+END_SRC

* Ledger

I've decided to start managing my expenses using =ledger-mode= in the continuing migration of my life out of my head and into emacs.

Disabled on 12/21/2020 because it turns out =ledger= doesn't run on Windows. All the more reason to move to *nix.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ledger-mode
    :mode ("\\.dat\\'"
           "\\.ledger\\'")
    :custom (ledger-clear-whole-transactions t))
#+END_SRC


* Misc Elisp tools
#+BEGIN_SRC emacs-lisp
  (defun ebpa/edebug-remove-all-instrumentation ()
    "Remove all edebug instrumentation by visiting each function
  definition and running `eval-defun`."
    (interactive)
    (mapatoms
     (lambda (symbol)
       (when-let (pos (car-safe (get symbol 'edebug)))
         (with-current-buffer (marker-buffer pos)
           (goto-char (marker-position pos))
           (eval-defun nil))))))
#+END_SRC

#+RESULTS:
: ebpa/edebug-remove-all-instrumentation

* Windows Subsystem for Linux

When I'm running Emacs in the WSL 2 environment, I'm often frustrated by the copy/paste bindings.

This seeks to fix that.

#+begin_src emacs-lisp
  (when (string-match "-[Mm]icrosoft" operating-system-release)
    (defconst powershell-exe "/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe")
    (when (file-executable-p powershell-exe)
      (defun my/wsl-browse-url (url &optional _new-window)
        "Opens link via powershell.exe"
        (interactive (browse-url-interactive-arg "URL: "))
        (let ((quotedUrl (format "start '%s'", url)))
          (apply 'call-process powershell-exe
                 nil 0 nil (list "-Command" quotedUrl))))
      (setq-default browse-url-browser-function 'my/wsl-browse-url))

    (defun wsl-copy (start end)
      "Copies the currect selection to the WSL clipboard"
      (interactive "r")
      (shell-command-on-region start end "clip.exe")
      (deactivate-mark))
    (defun wsl-paste ()
      "Pastes to the current buffer from the WSL clipboard"
      (interactive)
      (let ((clipboard
             (shell-command-to-string "powershell.exe -command 'Get-Clipboard' 2> /dev/null")))
        (setq clipboard (replace-regexp-in-string "\r" "" clipboard))
        (setq clipboard (substring clipboard 0 -1)) ; Remove newline added by Powershell
        (insert clipboard)))

    (global-set-key (kbd "C-c C-c") 'wsl-copy)
    (global-set-key (kbd "C-c C-v") 'wsl-paste))
#+end_src
